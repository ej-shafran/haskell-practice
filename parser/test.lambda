# BASIC FUNCTIONS

def identity x = x
def self_apply s = s s
def apply func arg = func arg

def select_first first second = first
def select_second first second = second
def make_pair e1 e2 c = c e1 e2

# BOOLEAN LOGIC

# we can write
#
# ```
# if c
#   then x
#   else y
# ```
#
# as
#
# ```
# (((
#   if c
# )
#   x)
#   y)
# ```

def if c t f = c t f
def true = select_first
def false = select_second

def not x = x false true
def and a b = a b false
def or a b = a true b

# INTEGERS

def succ n s = s false n

def zero = identity
def one = succ zero
def two = succ one
def three = succ two
def four = succ three
def five = succ four
def six = succ five
def seven = succ six
def eight = succ seven
def nine = succ eight

def is_zero n = n select_first

def pred1 n = n select_second
def pred n = (((is_zero n) zero) (n select_second))

def add1 _add x y = (((
    if (is_zero y)
  ) 
    x) 
    ((_add (succ x)) (pred y)))
def add = recursive add1

def sub1 _sub x y = (((
    if (is_zero y)
  ) 
    x) 
    ((_sub (pred x)) (pred y)))
def sub = recursive sub1

def mult1 _mult x y = (((
    if (is_zero y)
  ) 
    zero) 
    ((add x) ((_mult x) (pred y))))
def mult = recursive mult1

def div1 _div x y = (((
    if ((greater y) x)
  ) 
    zero) 
    (succ ((_div ((sub x) y)) y)))
def div2 = recursive div1
def div x y = (((
    if (is_zero y)
  ) 
    zero) 
    ((div2 x) y))

def equal1 _equal x y = (((
    if ((and (is_zero x)) (is_zero y))
  )
    true)
    (((
      if ((or (is_zero x)) (is_zero y))
    )
        false)
        ((_equal (pred x)) (pred y))))
def equal = recursive equal1

def greater x y = (not (is_zero ((sub x) y)))
def greater_or_equal x y = (is_zero ((sub x) y))
def less = flip greater
def less_or_equal = flip greater_or_equal

# FUNCTIONAL UTILS

def recursive f = (
  \s -> (f (s s))
  \s -> (f (s s))
)
def flip f = \a -> \b -> f b a

# TYPES

def make_obj type value = \s -> s type value
def type obj = obj select_first
def value obj = obj select_second
def is_type t obj = ((equal (type obj)) t)

def error_type = zero
def MAKE_ERROR = make_obj error_type
def ERROR = MAKE_ERROR error_type
def is_error = is_type error_type

def bool_type = one

def MAKE_BOOL = make_obj bool_type

def TRUE = MAKE_BOOL true
def FALSE = MAKE_BOOL false
def is_bool = is_type bool_type
def BOOL_ERROR = MAKE_ERROR bool_type

def NOT X = (((
    if (is_bool X)
  )
    (MAKE_BOOL (not (value X))))
    BOOL_ERROR)

def AND X Y = (((
    if ((and (is_bool X)) (is_bool Y))
  )
    (MAKE_BOOL ((and (value X)) (value Y))))
    BOOL_ERROR)

def IF C E1 E2 = (((
    if (is_bool C)
  )
    (((if (value C)) E1) E2))
    BOOL_ERROR)

def IS_ERROR E = MAKE_BOOL (is_error E)
def IS_BOOL B = MAKE_BOOL (is_bool B)

def numb_type = two
def MAKE_NUMB = make_obj numb_type
def NUMB_ERROR = MAKE_ERROR numb_type
def is_numb = is_type numb_type
def IS_NUMB N = MAKE_BOOL (is_numb N)

def 0 = MAKE_NUMB zero
def SUCC N = (((
    if (is_numb N)
  )
    (MAKE_NUMB (succ (value N))))
    NUMB_ERROR)

def 1 = MAKE_NUMB one
def 2 = MAKE_NUMB two
def 3 = MAKE_NUMB three
def 4 = MAKE_NUMB four
def 5 = MAKE_NUMB five
def 6 = MAKE_NUMB six
def 7 = MAKE_NUMB seven
def 8 = MAKE_NUMB eight
def 9 = MAKE_NUMB nine

def PRED N = (((
    if (not (is_numb N))
  )
    NUMB_ERROR)
    (((
        if (is_zero (value N))
    )
        NUMB_ERROR)
        (MAKE_NUMB ((value N) select_second))) 
    )

def IS_ZERO N = (((
    if (is_numb N)
  )
    (MAKE_BOOL (is_zero (value N))))
    NUMB_ERROR)

def both_numbs X Y = and (is_numb X) (is_numb Y)

def + X Y = (((
    if ((both_numbs X) Y)
  )
    (MAKE_NUMB ((add (value X)) (value Y))))
    NUMB_ERROR)

def * X Y = (((
    if ((both_numbs X) Y)
  )
    (MAKE_NUMB ((mult (value X)) (value Y))))
    NUMB_ERROR)

equal (value ((* 2) 2)) three
